Some of the worst problems with new and delete are as below:

Proper pairing of new and delete : Every dynamically allocated object that is created with new must be 
followed by a manual deallocation at a "proper" place in the program. If the programer forgets to call 
delete (which can happen very quickly) or if it is done at an "inappropriate" position, memory leaks 
will occur which might clog up a large portion of memory.

Correct operator pairing : C++ offers a variety of new/delete operators, especially when dealing with 
arrays on the heap. A dynamically allocated array initialized with new[] may only be deleted with the 
operator delete[]. If the wrong operator is used, program behavior will be undefined - which is to be 
avoided at all cost in C++.

Memory ownership : If a third-party function returns a pointer to a data structure, the only way of knowing who will be responsible for resource deallocation is by looking into either the code or the documentation. If both are not available (as is often the case), there is no way to infer the ownership from the return type. As an example, in the final project of this course, we will use the graphical library wxWidgets to create the user interface of a chatbot application. In wxWidgets, the programmer can create child windows and control elements on the heap using new, but the framework will take care of deletion altogether. If for some reason the programmer does not know this, he or she might call delete and thus interfere with the inner workings of the wxWidgets library.